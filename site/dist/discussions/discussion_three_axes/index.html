<!DOCTYPE html><html lang="ja"> <head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v5.17.2"><title>3軸Sybil対策の数学的妥当性を検証する</title><meta name="description" content="Concept.md の「距離・時間・エントロピー」三軸を検証。数学的には統合済み（距離軸は不要説）、実装面では段階的判断、哲学面では監視との境界と二層設計を議論。"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<style id="rich-discussion-style">
/* ===== Base ===== */
body {
  background: #0d1117 !important;
  color: #c9d1d9;
  font-family: 'Segoe UI', 'Noto Sans JP', sans-serif;
  line-height: 1.75;
  margin: 0; padding: 0;
}

/* ===== Site nav ===== */
header {
  background: #161b22 !important;
  border-bottom: 1px solid #30363d !important;
  padding: 0.8rem 1.5rem !important;
}
header nav a {
  color: #58a6ff !important;
  text-decoration: none;
  font-weight: 500;
  font-size: 14px;
  margin-right: 1.2rem;
}
header nav a:hover { text-decoration: underline; }

/* ===== Main / Article ===== */
main { max-width: 900px !important; margin: 0 auto; padding: 2.5rem 1.5rem !important; }

article > h1:first-of-type {
  font-size: 1.9rem;
  color: #58a6ff;
  border-bottom: 2px solid #30363d;
  padding-bottom: 0.6rem;
  margin-bottom: 0.4rem;
}
article > p:nth-of-type(1) { color: #8b949e; font-size: 13px; margin-bottom: 2rem; }

/* ===== Overview headings (争点, まとめ etc.) ===== */
article h2:not(.round-divider):not(.conclusion-title) {
  color: #f0f6fc;
  font-size: 1.15rem;
  border-left: 4px solid #388bfd;
  padding-left: 0.8rem;
  margin: 2.5rem 0 0.8rem;
}
article h1:not(:first-of-type) {
  color: #f0f6fc;
  font-size: 1.4rem;
  border-left: 4px solid #58a6ff;
  padding-left: 0.8rem;
  margin: 2rem 0 0.8rem;
}

/* ===== Round divider ===== */
.round-divider {
  border: none !important;
  padding: 0.6rem 1.6rem !important;
  background: linear-gradient(90deg, #0d1117, #1f2d3d, #0d1117) !important;
  border-top: 1px solid #388bfd !important;
  border-bottom: 1px solid #388bfd !important;
  color: #79c0ff !important;
  text-align: center;
  margin: 2.5rem 0 1.5rem !important;
  font-size: 0.95rem;
  letter-spacing: 0.04em;
}

/* ===== Speaker block ===== */
.speaker-block {
  display: flex;
  gap: 1rem;
  margin: 1.2rem 0;
  align-items: flex-start;
}
.speaker-label {
  flex-shrink: 0;
  width: 84px;
  padding: 0.35rem 0.5rem;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 700;
  text-align: center;
  margin-top: 6px;
  line-height: 1.4;
}
.speaker-content {
  flex: 1;
  background: #161b22;
  border-radius: 10px;
  padding: 1rem 1.3rem;
  border: 1px solid #30363d;
  min-width: 0;
}
.speaker-content p { margin: 0 0 0.6rem; }
.speaker-content p:last-child { margin-bottom: 0; }
.speaker-content ul, .speaker-content ol { padding-left: 1.4rem; margin: 0.4rem 0; }
.speaker-content li { margin-bottom: 0.3rem; }

/* Mathematician — blue */
.speaker-mathematician .speaker-label {
  background: rgba(88,166,255,0.15);
  color: #79c0ff;
  border: 1px solid rgba(88,166,255,0.4);
}
.speaker-mathematician .speaker-content { border-left: 3px solid #388bfd; }

/* Economist — green */
.speaker-economist .speaker-label {
  background: rgba(126,231,135,0.15);
  color: #7ee787;
  border: 1px solid rgba(126,231,135,0.4);
}
.speaker-economist .speaker-content { border-left: 3px solid #3fb950; }

/* Philosopher — purple */
.speaker-philosopher .speaker-label {
  background: rgba(210,168,255,0.15);
  color: #d2a8ff;
  border: 1px solid rgba(210,168,255,0.4);
}
.speaker-philosopher .speaker-content { border-left: 3px solid #8957e5; }

/* Architect — orange */
.speaker-architect .speaker-label {
  background: rgba(255,188,100,0.15);
  color: #ffa657;
  border: 1px solid rgba(255,188,100,0.4);
}
.speaker-architect .speaker-content { border-left: 3px solid #e3b341; }

/* Other */
.speaker-other .speaker-label {
  background: rgba(139,148,158,0.15);
  color: #8b949e;
  border: 1px solid rgba(139,148,158,0.4);
}
.speaker-other .speaker-content { border-left: 3px solid #6e7681; }

/* ===== Blockquotes (たとえ話) ===== */
.speaker-content blockquote, article > blockquote {
  background: rgba(56,139,253,0.07);
  border: 1px solid rgba(56,139,253,0.3);
  border-left: 4px solid #388bfd;
  border-radius: 6px;
  padding: 0.9rem 1.1rem;
  margin: 0.8rem 0 0;
  font-size: 0.93rem;
  color: #b0bec5;
}

/* ===== Conclusion ===== */
.conclusion-block {
  background: #161b22;
  border: 1px solid #30363d;
  border-radius: 10px;
  padding: 1.5rem;
  margin: 2rem 0;
}
.conclusion-title {
  color: #58a6ff !important;
  border-left: none !important;
  font-size: 1.2rem !important;
  margin: 0 0 1rem !important;
  padding: 0 !important;
}

/* ===== Glossary ===== */
.glossary-section { margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #30363d; }
.glossary-item {
  background: #161b22;
  border: 1px solid #30363d;
  border-radius: 8px;
  padding: 1rem 1.2rem;
  margin: 0.8rem 0;
}
.glossary-item h3 {
  color: #f0f6fc !important;
  font-size: 1rem !important;
  margin: 0 0 0.4rem !important;
}
.glossary-item p { font-size: 0.9rem; margin: 0; color: #c9d1d9; }

/* ===== Inline code ===== */
code { background: #1f2937; padding: 0.15em 0.4em; border-radius: 4px; font-size: 0.9em; color: #e2e8f0; }
pre { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 1rem; overflow-x: auto; }

/* ===== KaTeX ===== */
.katex-display { overflow-x: auto; padding: 0.5rem 0; }
</style>
</head> <body> <header style="border-bottom: 1px solid #30363d; padding: 1rem 1.5rem;"> <nav> <a href="/" style="margin-right: 1rem;">Meguri</a> <a href="/discussions/">議論一覧</a> </nav> </header> <main style="max-width: 800px; margin: 0 auto; padding: 2rem 1.5rem;">  <article> <h1>3軸Sybil対策の数学的妥当性を検証する</h1> <p style="color: #8b949e; margin-bottom: 1.5rem;">2026-02-15</p> <h1 id="3軸sybil対策の数学的妥当性を検証する">3軸Sybil対策の数学的妥当性を検証する</h1>
<p>Meguri Project — Three-Axes Sybil Resistance Discussion</p>
<h2 id="議題">議題</h2>
<p>Concept.md に記載された「距離・時間・エントロピー」の三軸評価が、現在の統合設計でどう実現されているか（または実現すべきか）を検証する。特に距離軸の要否、プライバシーとの整合性、実装可能性を精査。</p>
<h2 id="phase-1-三軸の統合状況数学的検証">Phase 1: 三軸の統合状況（数学的検証）</h2>
<h3 id="mathematician">mathematician</h3>
<p>結論から言うと、</p>
<p>三軸の独立スコアは不要</p>
<p>。既に他のメカニズムに統合されている：</p>
<ul>
<li><strong>時間軸</strong> → 減価の滞留ペナルティ <code>λ_stag·h(τ)</code> に統合済み</li>
<li><strong>エントロピー軸</strong> → 循環の質 Q_equity（フローの分散）+ VRF の均等配分に統合済み</li>
<li><strong>距離軸</strong> → <strong>不要</strong>（プライバシー矛盾、代替可能）</li>
</ul>
<p>前回指摘した5つの矛盾（次元不一致、符号矛盾、相互補完問題など）はすべて解決済み。独立した「三軸スコア」を作る必要はない。</p>
<blockquote>
<p>🎯 <strong>たとえると：</strong>「健康管理アプリ」で考えてみる。最初は「運動スコア」「食事スコア」「睡眠スコア」の三軸を表示していた。でも実際には、運動不足なら体重が増える（減価に影響）、食事バランスが悪いと健康診断で引っかかる（循環の質に影響）。つまり三軸は既に「体重」と「健康診断結果」に統合されているから、わざわざ別スコアを作る必要がない。</p>
</blockquote>
<blockquote>
<p><em>三軸の統合状況まとめ</em></p>
</blockquote>
<h3 id="mathematician-1">mathematician</h3>
<p>自己弱体化の数学的証明</p>
<p>を示す：</p>
<p>k個の巣を運用する効用を U(k) とすると、</p>
<p>U(k) = k·個別利益 − k²·時間分割コスト − k·運用コスト</p>
<p>計算すると</p>
<p>k≥3 で U(k) &#x3C; U(1)</p>
<p>が成立。つまり3つ以上の巣を持つと損失が発生する。</p>
<p>重要なのは、</p>
<p>この証明に距離情報は不要</p>
<p>。時間制約（1日24時間）だけで自己弱体化が成立する。</p>
<p>代替案：</p>
<p>巣間相関分析</p>
<p>（取引時刻の相関を検出）、</p>
<p>ネットワークトポロジー</p>
<p>（同じグループ内だけで取引）などで距離軸は代替可能。</p>
<blockquote>
<p>🎯 **たとえると：**3つのバイトを掛け持ちすると、各バイトで寝坊・疲労・ミスが増えて全部クビになる（自己弱体化）。「通勤距離が長い」という情報がなくても、「1日24時間しかない」という時間制約だけで掛け持ちは破綻する。相関分析は「2つのTwitterアカウントが毎回同じ時間に投稿 → 同一人物疑惑」みたいな検出方法。</p>
</blockquote>
<blockquote>
<p><em>自己弱体化の証明と距離軸の代替案</em></p>
</blockquote>
<h3 id="mathematician-2">mathematician</h3>
<p>推奨：</p>
<p>Concept.md の更新</p>
<p>「距離・時間・エントロピーの三軸」という表現を修正し、</p>
<p>「減価・循環の質・確率的配分の三層構造」</p>
<p>として再整理する。</p>
<p>これは「三軸」ではなく「三層」で、各層が独立したメカニズムとして機能し、全体として Sybil 耐性を実現する。距離・時間・エントロピーは、それぞれの層に埋め込まれた要素として位置づける。</p>
<blockquote>
<p>🎯 <strong>たとえると：</strong>「三軸」は3つの独立した物差し（縦・横・高さ）。「三層」は3つの防御壁（外壁・内壁・金庫室）。Meguri は後者。各層が違う役割を持ち、全部突破しないと攻撃できない多層防御。距離・時間・エントロピーは各層の「建材」として使われているが、独立した柱ではない。</p>
</blockquote>
<blockquote>
<p><em>Concept.md 更新の推奨</em></p>
</blockquote>
<h2 id="phase-2-段階的実装計画実装設計">Phase 2: 段階的実装計画（実装設計）</h2>
<h3 id="architect">architect</h3>
<p>実装難易度の評価：</p>
<ul>
<li><strong>エントロピー・時間軸：実装容易</strong> ★☆☆☆☆
取引データから直接算出可能。プライバシー懸念も最小。</li>
<li><strong>距離軸：実装可能だが慎重判断</strong> ★★★☆☆
GPS精度は粗い位置（100m-1kmグリッド）で十分。VPN対策にはデバイスローカルのセンサー（加速度計、ジャイロ）を使用。zk-SNARK で「移動の多様性」を秘匿証明可能。</li>
</ul>
<p>VRF統合：完全に可能</p>
<p>VRF と zk-SNARK は相乗効果あり。VRF が配分先を決定し、zk が証明の正当性を保証。</p>
<blockquote>
<p>🎯 **たとえると：**エントロピー・時間軸は「レシートを見れば買い物パターンがわかる」レベル（簡単）。距離軸は「スマホの歩数計で大まかな移動を推定」レベル（できるけど慎重に）。VPN対策は「VPNで位置偽装しても、歩数計は嘘つけない」という多重チェック。</p>
</blockquote>
<blockquote>
<p><em>実装難易度評価</em></p>
</blockquote>
<h3 id="architect-1">architect</h3>
<p>段階的実装の修正版</p>
<p>：</p>
<ul>
<li><strong>Phase 2: シミュレーション（1-2ヶ月）</strong> ← 新規追加
合成データで三軸の効果を検証</li>
<li><strong>Phase 1: エントロピーのみ（2-3ヶ月）</strong>
Q_equity + VRF のみで運用開始</li>
<li><strong>Phase 2: エントロピー+時間（3-4ヶ月）</strong>
滞留ペナルティ統合</li>
<li><strong>Phase 2.5: 評価期間（3-6ヶ月）</strong> ← 新規追加
二軸で十分か実データで検証。距離軸の可否判断。</li>
<li><strong>Phase 3: 距離軸（4-6ヶ月、条件付き）</strong>
Phase 2.5 の結果次第で実装</li>
</ul>
<p>推奨：</p>
<p>戦略A（保守的）</p>
<p>— Phase 2.5 で実データ判断してから距離軸の可否を決める。</p>
<blockquote>
<p>🎯 **たとえると：**新しい料理のレシピ開発。Phase 2 = 頭の中でシミュレーション。Phase 1 = 塩と胡椒だけで試作。Phase 2 = 醤油を追加。Phase 2.5 = 試食会で評価「これで完成？ それとも味噌も必要？」。Phase 3 = 必要なら味噌追加（条件付き）。最初から全部入れると、どれが効いてるかわからない。</p>
</blockquote>
<blockquote>
<p><em>段階的実装計画（Phase 2.5追加）</em></p>
</blockquote>
<h2 id="phase-3-監視との境界線世界観設計">Phase 3: 監視との境界線（世界観設計）</h2>
<h3 id="philosopher">philosopher</h3>
<p>「評価」と「監視」の境界を定義する。</p>
<p>五条件</p>
<p>：</p>
<ol>
<li>非人格化</li>
</ol>
<p>パターンのみを評価し、個人を特定しない。</p>
<ol start="2">
<li>目的限定</li>
</ol>
<p>Sybil検出と恩恵配分のみ。他の目的に流用しない。</p>
<ol start="3">
<li>対称性</li>
</ol>
<p>全員が同じルールで評価される。特権階級なし。</p>
<ol start="4">
<li>透明性</li>
</ol>
<p>アルゴリズムを公開。ブラックボックス禁止。</p>
<ol start="5">
<li>主権在民</li>
</ol>
<p>データはユーザーのデバイスに保存。中央サーバーに送信しない。</p>
<blockquote>
<p>🎯 **たとえると：**監視カメラ（誰がどこにいたか記録、顔認証で個人特定）vs 体温計（熱があるか二値判定のみ、名前は記録しない）。Meguri が目指すのは後者。非人格化は「年齢確認（20歳以上かどうかだけ）」vs「顔認証（あなたは山田太郎）」の違い。前者は個人を特定しない。</p>
</blockquote>
<blockquote>
<p><em>監視との境界 ─ 五条件</em></p>
</blockquote>
<h3 id="philosopher-1">philosopher</h3>
<p>活動制限者への配慮</p>
<p>が必要：</p>
<p>距離軸は障がい者・高齢者・貧困層に不利。「移動できない = 悪い」という評価になってしまう。</p>
<p>解決策：</p>
<ul>
<li><strong>移動「量」→「一貫性」への再定義</strong>
在宅ワーカーが毎日同じ場所 = 自然。毎日東京-大阪往復 = 不自然。</li>
<li><strong>軸間代替性</strong>
距離が低くてもエントロピー・時間が高ければOK。</li>
<li><strong>絶対評価ではなく異常検出</strong>
「低い = 悪い」ではなく「パターンが不自然 = 疑義あり」。</li>
</ul>
<blockquote>
<p>🎯 **たとえると：**車椅子の人と健常者で「移動の自然さ」の基準を変える。車椅子の人が毎日家の周り500m = 自然。健常者が毎日500mだけ = 少し不自然かも。でも車椅子の人が「取引相手が多様」（エントロピー高）なら全く問題なし（軸間代替性）。評価は「この人は怠け者」ではなく「このパターンは2つの別人が演じている可能性」（異常検出）。</p>
</blockquote>
<blockquote>
<p><em>活動制限者への配慮</em></p>
</blockquote>
<h3 id="philosopher-2">philosopher</h3>
<p>二層設計</p>
<p>を提案する：</p>
<p>第一層：異常検出（Sybil対策）</p>
<p>二値出力：正常 / 疑義あり。閾値は厳しく設定。</p>
<p>第二層：恩恵配分基礎（促進的機能）</p>
<p>連続スコア。ただし効果は薄く（減価の±5%程度）。</p>
<p>この分離により、Sybil検出（セキュリティ）と循環促進（インセンティブ）を独立に調整できる。</p>
<p>さらに</p>
<p>スコアレス設計</p>
<p>を提案：デフォルトでスコアは非表示。ユーザーが要求したときのみ開示。「体温は測るが、毎日数値を見ない」という生き方。</p>
<blockquote>
<p>🎯 **たとえると：**空港の荷物検査。第一層 = 金属探知機で異常検出（ピーッと鳴ったら疑義あり）。第二層 = 開封して中身確認（グラデーションで評価）。最初から全員の荷物を開けたら大混乱（一層だけだと厳しすぎ）。スコアレス設計は「健康診断の数値を見ないで生きる。医者が『問題ない』と言えばそれで十分」。毎日体重計に乗って一喜一憂しない生き方。</p>
</blockquote>
<blockquote>
<p><em>二層設計 &#x26; スコアレス設計</em></p>
</blockquote>
<h2 id="対立議論ポイント">対立・議論ポイント</h2>
<ul>
<li><strong>距離軸の要否</strong> ─ mathematician「不要（時間制約だけで自己弱体化成立、プライバシー矛盾）」vs architect「Phase 2.5で判断（技術的には可能）」vs philosopher「再定義すれば可（量→一貫性）、ただし活動制限者への配慮必須」。三者三様の立場。</li>
<li><strong>三軸スコアの設計</strong> ─ mathematician「独立スコア廃止、既に統合済み」vs architect「段階的実装で効果を実測」vs philosopher「二層設計で異常検出と促進を分離」。実装パターンの違い。</li>
<li><strong>スコアの可視化</strong> ─ philosopher が独自提案した「スコアレス設計（デフォルト非表示）」は、透明性（アルゴリズム公開）とのバランスをどう取るか。「アルゴリズムは公開、個人スコアは非表示」で整合するか要検討。</li>
</ul>
<h2 id="次のステップ">次のステップ</h2>
<p><strong>次のステップ：</strong>
Phase 2（シミュレーション）で三軸の効果を定量検証。特に距離軸の有無で Sybil 耐性がどれだけ変わるか数値化。architect の Phase 2.5 評価期間を設定し、実データで二軸の十分性を判断。philosopher の二層設計とスコアレス設計を技術仕様に落とし込み、プロトタイプで UX を検証。Concept.md は mathematician 提案の「三層構造」に更新。</p>
<h2 id="用語集">用語集</h2>
<h3 id="sybil-攻撃">Sybil 攻撃</h3>
<p>1人が複数の偽アカウント（巣）を作成し、別人のふりをして不当に利益を得る攻撃手法。Meguri では KYC に頼らず、行動パターンの構造的評価で対策する。</p>
<p><strong>今回の議論：</strong> 今回の議論： 三軸（距離・時間・エントロピー）で対策する構想が、実際には「三層構造」に統合されている。</p>
<h3 id="proof-of-being存在証明">Proof of Being（存在証明）</h3>
<p>「何をしたか」ではなく「どう存在しているか」を評価する Meguri 独自の概念。距離・時間・エントロピーの三軸で自然な存在のしかたを統計的に評価する。</p>
<p><strong>今回の議論：</strong> 今回の議論： mathematician が「独立スコア不要」と指摘。三軸は既に減価・循環の質・VRF に統合されている。</p>
<h3 id="zk-snark">zk-SNARK</h3>
<p>「Zero-Knowledge Succinct Non-Interactive Argument of Knowledge」の略。データを明かさずに条件を満たすことを数学的に証明する暗号技術。</p>
<p><strong>今回の議論：</strong> 今回の議論： architect が距離軸の実装方法として言及。「位置情報は見せずに、移動の多様性を証明」が可能。</p>
<h3 id="巣間相関分析">巣間相関分析</h3>
<p>複数の巣の行動パターン（特に取引時刻）の相関を統計的に検出する手法。高い相関 = 同一人物の可能性。</p>
<p><strong>今回の議論：</strong> 今回の議論： mathematician が距離軸の代替案として提案。2つのTwitterアカウントが毎回同じ時間に投稿 → 同一人物疑惑。</p>
<h3 id="ネットワークトポロジー">ネットワークトポロジー</h3>
<p>ネットワークの構造（誰と誰が繋がっているか）。Meguri では取引関係のグラフ構造を解析し、閉じたグループを検出。</p>
<p><strong>今回の議論：</strong> 今回の議論： mathematician が距離軸の代替案として提案。複数巣が同じ小グループ内でしか取引していない → Sybil疑惑。</p>
<h3 id="自己弱体化">自己弱体化</h3>
<p>Sybil 攻撃（複数巣運用）が、攻撃者自身にダメージを与える構造。リソース（時間・注意・資本）の分割により、各巣のパフォーマンスが低下。</p>
<p><strong>今回の議論：</strong> 今回の議論： mathematician が数学的に証明。k≥3 巣で U(k) &#x3C; U(1)（3つ以上の巣を持つと損失）。時間制約だけで成立、距離情報不要。</p>
<h3 id="vrf検証可能ランダム関数">VRF（検証可能ランダム関数）</h3>
<p>暗号学的に安全な乱数生成関数。生成者が結果を操作できず、かつ第三者が正当性を検証可能。Mana の配分先決定に使用。</p>
<p><strong>今回の議論：</strong> 今回の議論： エントロピー軸の一部として統合済み。均等確率（1/n）を暗号学的に保証。architect が zk-SNARK との相乗効果を指摘。</p>
<h3 id="非人格化">非人格化</h3>
<p>個人を特定せず、パターンのみを評価する設計。「誰が」ではなく「どんな行動パターンか」だけを見る。監視との境界を定める重要概念。</p>
<p><strong>今回の議論：</strong> 今回の議論： philosopher が「監視との境界五条件」の第一項として提示。顔認証（個人特定）vs 年齢確認（20歳以上かどうかだけ）。</p>
<h3 id="異常検出anomaly-detection">異常検出（Anomaly Detection）</h3>
<p>統計的に正常な範囲から外れたパターンを検出する手法。「低い = 悪い」という絶対評価ではなく、「パターンが不自然」という相対評価。</p>
<p><strong>今回の議論：</strong> 今回の議論： philosopher が二層設計の第一層として提案。金属探知機（ピーッと鳴ったら疑義あり）のような二値判定。</p>
<h3 id="スコアレス設計">スコアレス設計</h3>
<p>philosopher が提案した、スコアをデフォルトで非表示にする UI 設計。「体温は測るが、毎日数値を見ない」という生き方。スコア最適化ゲームを防ぐ。</p>
<p><strong>今回の議論：</strong> 今回の議論： 透明性（アルゴリズム公開）と両立可能。「健康診断の数値を見ないで生きる。医者が『問題ない』と言えばそれで十分」。</p>
<h3 id="phase-25評価期間">Phase 2.5（評価期間）</h3>
<p>architect が新規追加した実装フェーズ。エントロピー+時間の二軸で運用し、実データで十分性を検証する期間（3-6ヶ月）。距離軸の可否を判断。</p>
<p><strong>今回の議論：</strong> 今回の議論： 試食会で「これで完成？ それとも味噌も必要？」と評価する段階。最初から全部入れると、どれが効いてるかわからない。</p> </article>  </main> 
<script>
(function(){
  var article = document.querySelector('article');
  if (!article) return;

  var speakerMap = {
    '数学者': 'mathematician',
    'ゲーム経済学者': 'economist',
    '哲学者': 'philosopher',
    'アーキテクト': 'architect',
    'architect': 'architect',
    '議事録係': 'other',
    '春日': 'other',
  };

  var nodes = Array.from(article.childNodes);
  var frag = document.createDocumentFragment();
  var speakerBlock = null;
  var speakerContent = null;
  var inGlossary = false;
  var glossaryItem = null;
  var conclusionBlock = null;

  nodes.forEach(function(el) {
    if (el.nodeType !== 1) { // text node
      if (speakerContent) speakerContent.appendChild(el.cloneNode(true));
      else frag.appendChild(el.cloneNode(true));
      return;
    }
    var tag = el.tagName;
    var txt = el.textContent.trim();

    if (tag === 'H2') {
      speakerBlock = null; speakerContent = null; glossaryItem = null;
      if (/^Round\s*\d+/.test(txt) || /^最終結論/.test(txt)) {
        el.classList.add('round-divider');
        inGlossary = false; conclusionBlock = null;
        frag.appendChild(el);
      } else if (txt === '用語集') {
        var gs = document.createElement('div');
        gs.className = 'glossary-section';
        var gh = el.cloneNode(true);
        gh.style.cssText = 'color:#58a6ff;font-size:1.2rem;margin-bottom:1rem;';
        gs.appendChild(gh);
        frag.appendChild(gs);
        inGlossary = true; conclusionBlock = gs;
      } else {
        inGlossary = false; conclusionBlock = null;
        frag.appendChild(el);
      }
    } else if (tag === 'H3') {
      if (inGlossary) {
        glossaryItem = document.createElement('div');
        glossaryItem.className = 'glossary-item';
        var gh3 = el.cloneNode(true);
        glossaryItem.appendChild(gh3);
        if (conclusionBlock) conclusionBlock.appendChild(glossaryItem);
        else frag.appendChild(glossaryItem);
        speakerContent = glossaryItem;
      } else {
        var speakerKey = null;
        Object.keys(speakerMap).forEach(function(k){ if (txt.indexOf(k) !== -1) speakerKey = k; });
        var cls = speakerKey ? speakerMap[speakerKey] : 'other';
        speakerBlock = document.createElement('div');
        speakerBlock.className = 'speaker-block speaker-' + cls;
        var label = document.createElement('div');
        label.className = 'speaker-label';
        label.textContent = speakerKey || txt;
        speakerContent = document.createElement('div');
        speakerContent.className = 'speaker-content';
        speakerBlock.appendChild(label);
        speakerBlock.appendChild(speakerContent);
        frag.appendChild(speakerBlock);
      }
    } else {
      if (speakerContent) {
        speakerContent.appendChild(el);
      } else {
        frag.appendChild(el);
      }
    }
  });

  article.innerHTML = '';
  article.appendChild(frag);
})();
</script>
</body></html>